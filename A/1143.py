class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n = len(text1)
        m = len(text2)
        
        dp = [[0]*(m+1) for _ in range(n+1)]
        
        for i in range(1,n+1):
            for j in range(1,m+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[n][m]
        
        """В чем идея: динамическое программирование
           1. Понять какие есть подзадачи.  Два символа могут быть равны или нет.
              Если символы равны, то ответ 1 + решение задачи на строках без этого символа.
              Если символы не равны, то ответ это максимум из решений: на строках s1[:-1] и s2,
              и на строках s1 и s2[:-1], т.е. поскольку последние символы не равны, то нельзя просто
              так отбросить их, нужно просмотреть оптимум по каждой строке без такого символа, который
              уже должен быт вычислен на предыдущем шаге. Таким образом:
           2. Определение функции перехода. Пусть dp[i][j] = lcs(text1[0..i], text2[0..j]). Тогда:
              dp[i][j] = dp[i-1][j-1] + 1 if text1[i] == text2[j] else max(dp[i-1][j], dp[i][j-1])
           3. Определение базы. dp[0][j] = 0 and dp[i][0] = 0 поскольку пустая строка не содежрит символов,
              и соответственно не может иметь ничего общего с другой строкой, в которой есть символы.
              
              
           """